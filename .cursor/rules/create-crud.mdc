---
alwaysApply: false
---

# Create CRUD

This is a Playbook on how to create a CRUD using the following technologies:

- React
- Zod
- AG Grid
- Mantine
- React Hook Form
- Supabase
- dayjs (optional)

We like to create very standardized way, this make it so it's for the user to understand.

The way we like to build CRUDs is by creating a table using AG Grid so the user can see the data, and on each line the last row.

## Folder structure

```
components
    <module-name>
        <name>
            components
              <name>.tsx
              <name>-form.tsx
              <name>-table.tsx
          hooks
              use-<name>-column-defs.tsx
          utils
              <name>-form-utils.ts
      queries
          <name>-query.ts
```

IMPORTANT:

- DO NOT create `index.ts` files

## Steps

### Create the base folder

Sometimes the developer will have provided a folder for you to use. If so, skip this step

If not, create a folder with the base name. this folder will house most of the parts of this CRUD

### Determining the shape of the data

The user should have provided context on what the data is that we are building. Think about the data schema and how it wil be store by supabase's PostgresSQL database, and how it will be handled by the form

#### Creating the table in the database

1. Create a new migration file with the command `supabase migration new <migration-name>`
1. Created an table with SQL (PostgreSQL) and it's schema.
1. Enable RLS

IMPORTANT:

- Depending on the <name> provided by the dev, figure out if the name of the fields should be in English or Brazilian Portuguese without accents.
  - Example: If "apoiador" (pt-BR) use "criador_em etc..", If supporter (en-US) use "created_at, etc.."
- Always create a criador_em or created_at column, but no need to create updated_at column unless the developer specified. That would add too much complexity
- Always favor bigint id columns. I like them to be create as such: `id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY`
- The policies' description should follow the pattern: `"grant <WHAT> to <WHO>"` Examples: "grant SELECT to users in the tenant", "grant UPDATE to users in the tenant"
- The table name should always be singular
- The id column should be `<name>_id`

### Creating query utils

- Run the command `bun db:generate-types` to generate typescript types from the database
- Now, create a `<name>-query.ts` file in the lib/queries folder, like in the example

```ts
// Switch "imposto" with the "name"

import type { Tables, TablesInsert } from '@/lib/supabase/database-types';
import { EMPRESA_COLUMNS_BASE } from './empresa-query';

// To use as the return type in select operations
export type Imposto = Tables<{ schema: 'contabilidade' }, 'imposto'>;
// To use in insert or upsert operations. Is less restrictive than the Imposto type
export type ImpostoInsert = TablesInsert<
  { schema: 'contabilidade' },
  'imposto'
>;

// The name of the table
export const IMPOSTO_TABLE = 'Impostos';
// The base columns of the table
export const IMPOSTO_COLUMNS_BASE = `
    imposto_id,
    empresa_id,
    criador_em,
    data,
    nome,
    valor
`;
// The columns of the table, plus foreign columns so that supabase can join the tables
export const IMPOSTO_COLUMNS = `
    ${IMPOSTO_COLUMNS_BASE},
    empresa ( ${EMPRESA_COLUMNS_BASE} )
`;
```

IMPORTANT:

- DO NOT add the same comments as the example above in the final file.

#### Creating form utils

In the `<name>-form.ts` file, create utils that will be used for the form

Example:

```ts
import { Imposto, ImpostoInsert } from '@/lib/queries/imposto-query';
import dayjs from 'dayjs';
import { z } from 'zod';

// Create a default values constant named, in capitalized case `<NAME>_DEFAULT_VALUES`
// Be explicit about the types, since it will be used to create the `<Name>FormValues` later
export const IMPOSTO_DEFAULT_VALUES = {
  imposto_id: null as number | null,
  empresa_id: null as number | null,
  nome: '',
  valor: 0,
  data: dayjs().startOf('month').format('YYYY-MM-DD'),
};

// Create a zod schema that will be used to validate the form and also derive the form values's type
export const impostoSchema = z.object({
  imposto_id: z.number().nullable(),
  empresa_id: z.number(),
  nome: z.string(),
  valor: z.number(),
  data: z.string(),
});

// Create the type for the values before validation and after validation. most of the times these two are the same
export type ImpostoValidFormValues = z.infer<typeof impostoSchema>;
export type ImpostoFormValues = typeof IMPOSTO_DEFAULT_VALUES;

// Create a `to<name>Table` function that converts the valid form values to the values need to insert in the table

export function toImpostoTable(values: ImpostoValidFormValues): ImpostoInsert {
  const data: ImpostoInsert = {
    empresa_id: values.empresa_id,
    nome: values.nome,
    valor: values.valor,
    data: values.data,
  };

  // To make it so this function works for insert and update operations, the primary key of table
  // needs to be added like this. Supabase does not like explicit undefined fields.
  // It assumes you're trying to set the id field to undefined
  if (values.imposto_id) {
    data.imposto_id = values.imposto_id;
  }

  return data;
}

// Create a `from<name>Table` function that converts the values from the table to valid form values
export function fromImpostoTable(values: Imposto): ImpostoValidFormValues {
  return {
    empresa: {
      selectedIds: [values.empresa_id.toString()],
    },
    nome: values.nome,
    valor: values.valor,
    data: values.data,
  };
}
```

IMPORTANT:

- DO NOT add the same comments as the example above in the final file.
- Try not to use comments. ONLY USE comments if you need to explain something the developer might not know (a pitfall or quirk).

### Create the base component

```tsx
'use client';

import { FormProvider, useForm } from 'react-hook-form';
import {
  fromImpostoTable,
  IMPOSTO_DEFAULT_VALUES,
  impostoSchema,
} from '../utils/imposto-form';
import { useDisclosure } from '@/packages/mantine';
import dynamic from 'next/dynamic';
import {
  IMPOSTO_TABLE,
  Imposto as ImpostoType,
} from '@/components/contabilidade/shared/queries/imposto-query';
import { ImpostoTable } from './imposto-table';
import { Button } from '@mantine/core';
import { useRef } from 'react';
import { AgGridReact } from 'ag-grid-react';
import { createClient } from '@/lib/supabase/client';
import { useMutation } from '@tanstack/react-query';
import { zodResolver } from '@hookform/resolvers/zod';

// NOTE: Since imposto is inside a Drawer, importing it dynamically (lazy-loading)
// has no visual downsides, and reduces bundle size
const ImpostoForm = dynamic(
  () => import('./imposto-form').then((mod) => mod.ImpostoForm),
  { ssr: false }
);

export function Imposto() {
  const gridRef = useRef<AgGridReact>(null);

  const formDisclosure = useDisclosure();
  const form = useForm({
    defaultValues: IMPOSTO_DEFAULT_VALUES,
    // @ts-expect-error --- valid type are different from the default values
    resolver: zodResolver(impostoSchema),
  });

  const supabase = createClient();
  const deleteMutation = useMutation({
    mutationFn: async (impostoId: number) => {
      const { data } = await supabase
        .schema('contabilidade')
        .from(IMPOSTO_TABLE)
        .delete()
        .eq('imposto_id', impostoId)
        .throwOnError();

      return data;
    },
    onSuccess: () => {
      gridRef.current?.api.refreshServerSide();
    },
  });

  const onEdit = (value: ImpostoType) => {
    form.reset(fromImpostoTable(value));
    formDisclosure.open();
  };

  const onCreate = () => {
    form.reset(IMPOSTO_DEFAULT_VALUES);
    formDisclosure.open();
  };

  const onDelete = (value: ImpostoType) => {
    deleteMutation.mutate(value.imposto_id);
  };

  return (
    <FormProvider {...form}>
      <div className="container min-h-dvh flex flex-col pt-5 px-4 sm:px-6 lg:px-8">
        <div className="flex flex-col sm:flex-row sm:items-center pb-5">
          <div className="sm:flex-auto">
            <h1 className="text-xl font-semibold text-gray-9 dark:text-dark-0 leading-none">
              Impostos extras
            </h1>
            <p className="mt-2 text-sm text-gray-7 dark:text-dark-2 leading-none">
              Aqui você pode adicionar impostos extras que não foram obtidos da
              fonte de dados
            </p>
          </div>
          <div className="mt-4 sm:mt-0 sm:ml-16 sm:flex-none">
            <Button type="button" onClick={onCreate}>
              Adicionar imposto
            </Button>
          </div>
        </div>
        <div className="grow">
          <ImpostoTable gridRef={gridRef} onEdit={onEdit} onDelete={onDelete} />
        </div>
      </div>

      <ImpostoForm gridRef={gridRef} disclosure={formDisclosure} />
    </FormProvider>
  );
}
```

### Creating the form

### Creating the Column Defs hook

In AG Grid, each column in the grid is defined using a Column Definition (ColDef). Columns are positioned in the grid according to the order the Column Definitions are specified in the Grid Options.

```tsx
const [columnDefs, setColumnDefs] = useState([
  { field: 'athlete' },
  { field: 'sport' },
  { field: 'age' },
]);

<AgGridReact columnDefs={columnDefs} />;
```

Use defaultColDef to set properties across ALL Columns.

```tsx
const defaultColDef = useMemo(() => {
  return {
    width: 150,
    cellStyle: { fontWeight: 'bold' },
  };
}, []);

<AgGridReact defaultColDef={defaultColDef} />;
```

Create a hook that returns three things:

- columnDefs
- setColumnDefs
- defaultColDef

IMPORTANT:

- If a property is present in all columns, pass it to defaultColDef to reduce code duplication

### Creating the table

IMPORTANT:

- Always use the component `<CustomHeader />` for every header
- Find icons from phosphor-icons to use in the CustomHeader component
- Always pass the theme from `useAgGridTheme`. It is a hook that integrates the styles with mantine styles
